


// Audio constraints
// consumer MUST provide a context
// consumer a provide a src and/or destination node, otherwise the userMedia/destination will be used  



An AudioContext is shared between all devices by default using the AudioService.
When the consumer provides an audioContext the createAudioContext method is called with that as an argument, else it should be called with null as an argument, which will create an audioContext.


import * as MyLibrary from 'my-library';
// assum my-library is a module that exports a component app-device
import { Component, ViewChild } from '@angular/core';
import { Subject } from 'rxjs';


// Consumer example

@Component({
  selector: 'ngx-rnbo-device',
  standalone: true,
  imports: [],
  template: `
  <app-device #deviceA ></app-device>
  <app-device #deviceB ></app-device>
  <app-device #deviceC ></app-device>
  `,
  styles: ``
})
export class ExampleConsumerComponent {
    @ViewChild('deviceA') deviceA!: MyLibrary.DeviceComponent;
    constructor() { 

    }
    ngOnInit() {
        this.deviceA.audioContext.next(new AudioContext());
    }


}


// Library Service

import { Injectable } from '@angular/core';

@Injectable({
  providedIn: 'root'
})
export class MyLibraryAudioService {
    audioContext!: AudioContext;
  constructor() {
   }
   start() {
        this.audioContext = new AudioContext();
        this.audioContext.resume();
   }
}


@Component({
  selector: 'app-device',
  standalone: true,
  template: `
  <div>
    <button (click)="startContext()">CLick to Start Audio</p>
    <p *ngIf="isRunning()">Audio is running</p>
</div>
  `,
  styles: [``]
});
export class DeviceComponent {
  audioContext =  new Subject<AudioContext|null>(null);
  constructor(public service: MyLibraryAudioService) { }
  startContext() {
    if(this.audioContext() === null) {
        if(this.service.audioContext === null){

            this.service.start();
            this.audioContext.set(this.service.audioContext);
        }
        else {
            this.audioContext.set(this.service.audioContext);
        }
    } 
    else {
        this.audioContext().resume();
    }
  }
  isRunning(){
        return this.audioContext.value.state === 'running';
   
  }
}